\documentclass[mscthesis]{usiinfthesis}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{float}
\usepackage{tabularx}

\lstdefinelanguage{algebra}
{morekeywords={import,sort,constructors,observers,transformers,axioms,if,
else,end},
sensitive=false,
morecomment=[l]{//s},
}



\title{Blochchain BAR Gossip} %compulsory
\specialization{Dependable Distributed Systems}%optional
\subtitle{Reliable and clustered gossiping protocol} %optional 
\author{Gianmarco Fraccaroli} %compulsory
\begin{committee}
\advisor{Prof.}{Fernando}{Pedone} %compulsory
% \coadvisor{Prof.}{Student's}{Co-Advisor}{} %optional
\end{committee}
\Day{Yesterday} %compulsory
\Month{September} %compulsory
\Year{2019} %compulsory, put only the year
\place{Lugano} %compulsory

\dedication{To my beloved} %optional
\openepigraph{Someone said \dots}{Someone} %optional

%\makeindex %optional, also comment out \theindex at the end

\begin{document}

\maketitle %generates the titlepage, this is FIXED

\frontmatter %generates the frontmatter, this is FIXED

\begin{abstract}
This is a very abstract abstract. 
\end{abstract}

% \begin{abstract}[Zusammenfassung]
% optional, use only if your external advisor requires it in his/er
%l anguage 
% \\

%\lipsum
%\end{abstract}

\begin{acknowledgements}
\end{acknowledgements}

\tableofcontents 
\listoffigures %optional
\listoftables %optional

\mainmatter

\chapter{Introduction}
During the last ten years, after the born of Bitcoin, blockchain-based systems became an important building block in several applications, ranging from financial to legal services. As the need for this kind of distributed structured grew, more advanced and sophisticated versions have been built to meet real-world throughput demands. \\
In fact, as the current Bitcoin protocol can handle only seven transactions per second, other protocols like Tendermint or Hyperledger can handle volumes of operations in the order of thousands per second. \\
This is because the latter systems differ in the consensus mechanism, allowing for better performance and higher scalability at the cost of less decentralization. \\
One of the aspects which is typical for most of those systems is the fact that they exchange information through a gossip protocol. Most of the time, this network can be freely joined by anyone, meaning that everyone receives and share updates on the state with other peers. 
As receiving updates reliably and quickly is a key aspect for these kinds of protocols, the P2P network is a crucial aspect as it offers many advantages and disadvantages. \\
Building a faster, safer, and more reliable gossip protocol for blockchains would improve the overall of those systems, making them closer to real-world scenarios needs.


\section{Motivation}
Blockchain systems offer an alternative way to settle an operation between two parties without having to rely on a trusted third party. The most famous and common example is the use of Bitcoin as a method of payments without having to rely on a bank or any other financial service. \\
This is particularly useful because it is possible to decrease the costs associated with the service offered by the mediator and acquire a higher level of trust as the operations can be carried on just by the two (or more) persons involved in the exchange.  \\
As we said before, due to the decentralized nature of these systems, gossip protocols, also called P2P, are heavily employed since they offer a high degree of scalability, fault-tolerance, robustness, fast-spreading and resilience, proprieties which are a perfect match for a decentralized system. \\
Still, these protocols have their disadvantages. First of all, as anyone can join the network without any sort of registration, it is hard to account for their behaviour and punish it. Being not able to punish peers for their incorrect behaviour is even worse in cases where this is done on purpose leading to Sybil or Eclipse attacks (which are going to be discussed later on).\\
So, due to the crucial role of the gossip protocol in a blockchain system, we need to be able to ensure its correctness even in the presence of malicious peers.

\section{Scope}
Gossip protocols used in blockchain-context don't usually take into consideration malicious peer, or if they do, they generally use easy and simplistic countermeasures. 
Since most of the blockchain networks are freely joinable by anyone, malicious peers can't be punished by the system in case of bad behavior as it is always possible for them to change identity and rejoin the system at zero cost.
This thesis aims to find a way to account peers for their behavior, punishing those who either try to gain more benefits at the expense
of other peers or try to slow or even disrupt the system. This goal has to be though in a context where gossip is a crucial aspect of the system, meaning that a slow, inefficient, or expensive protocol would have a significant impact on the overall performance.


\section{Structure of the thesis}
The remaining chapters are going to be structured in the following way. \\
First of all, the next chapter will cover some key concept about blockchains, gossip protocols, and BAR model. \\
The third chapter will then discuss in detail the Blockchain BAR Gossip protocol in all his components, from the model assumption to the different phases. \\
The fourth chapter and fifth chapter will be used to discussed the validity of the implementation of out prototyped simulation and on the experiments derived. \\
Finally, in the last chapter draws the conclusions of this work, discussing some possible future works.

\chapter{Background}
This chapter will outline the concepts and structures related to this thesis in order to better understand the challenges and solutions of the BBAR protocol.

\section{Blockchain}
Blockchain is distributed systems composed of cryptographically linked blocks, where each block store information about the state up to that point in time. Participants in a blockchain network cooperate in order to agree and keep a copy of the common state. This state is often called ledger. \\
Members of the network decide which state is correct by processing information through a common set of rules called consensus. Consensus rules goal is to agree on a common progression of blocks and prevent bad actors from altering it. \\
Blockchain systems are usually divided into three main groups: public blockchains (permissionless), consortium blockchains, and private blockchains (permissioned). \\
The main difference between permissioned and permissionless blockchains is the fact that in the latter, everyone is welcome to be part of the network and take part in the core activities meanwhile the former present a central authority who is in charge of validating, writing information, and selecting who is able to read transactions.  \\
Instead, consortium blockchains, also known as federated blockchain, are semi-public systems controlled by a group of members. They lie in the middle between public and private blockchains. \\
This difference is of key importance for our work as peer identities are unknown in public blockchains and known in private blockchains. Instead, peer identities in federated blockchain are project dependent.

\subsection{Consensus}
As most of the features are common for most blockchain systems, what makes the great majority of them unique is the way they reach consensus. Briefly, it is possible to describe consensus mechanism as the set of rules which make sure that everyone agrees upon which information and state are correct. \\
As we said before, there exist several types of consensus, with the most famous being: Proof of Work, Proof of Stake, Delegated Proof of Stake, and Proof of Authority.
The first one, PoW, is used by Bitcoin and consists of a competition among peers in the network to find a solution to a cryptographic puzzle. These peers are called miners; the "solution" is called hash-puzzle. \\
As more and more peers join the network to find a valid hash-puzzle, the difficulty of the puzzle increase. \\
The second one, PoS, doesn't exploit any computationally hard puzzle but instead gives the possibility to any member of the network to 'stake' an amount of currency to be probabilistically assigned a chance to be the one validating the block. \\
DPoS is similar to PoS but employs a more democratic system to choose the peer who will be validating the next block. The last one is PoA and works in a similar way to PoS. In fact, only a set of peers, called validators, are able, after reaching a supermajority, to add the next block to the chain. Validators are required to stake an amount of currency that will be slashed in case of misbehaviour. Moreover, their identity is public.


\section{Gossip}
Gossip protocols work by periodically exchanging information between members of the network. The exchange works in the following way: first, a peer selects randomly another peer in the system. Later, it contacts the peer and starts to share information with him based on a specific strategy. As peers are chosen randomly, this ensures that there will be a time T in which every peer knowns about every information. \\
These kinds of protocols are usually compared to epidemic diseases as their mathematical proprieties are really similar. One of the main proprieties is the so-called spreading rate, which describes how many hosts get infected as a function of round and the number of infections per host:
$$Y_r = \frac{1}{1 + ne^{-f}r}$$
where $r$ is the round, f is the number a host will infect each round, $Y_r$ is the number of infected hosts in round $r$. Basically, the convergence rate of a gossip protocol is based on how many exchanges he can execute each round and the number of rounds with an increase factor of $e^f$ per round. \\
Benefits of gossip protocols are:
\begin{itemize}
	\item High scalability, as messages need on average $\log(N)$ round to reach every node and node need to send a constant amount of messages independently from the size of the network.
	\item Fault tolerance, since nodes connectivity and irregularities in their behaviour, can be tolerated up to a certain level. Moreover, the same information can be provided by different peers meaning that there is a certain level of redundancy.
	\item High convergence rate, as we have seen above,  peers reach a global state exponentially quickly.
	\item Simplicity, as every node runs the same code.
	\item Resilience, as there are exponentially many routes by which information can flow from its source to its destinations.
\end{itemize}
\newpage
Still, gossip protocols have also his disadvantages:
\begin{itemize}
	\item Fragile with malicious peers, as many attacks can be carried on a gossip protocol that would break the whole system.
	\item Message size limits the scalability of the system, meaning that if information cannot be encoded into a single message, it will require another round of spreading, decreasing the overall scalability.
\end{itemize}
\subsection{Type of gossip protocols}
There exist several kinds of gossip protocol strategies, but most of them are based on the concepts of pull and pull. \\
In push-based strategies, as soon as a node receives a new update, it randomly selects a peer and sends the full payload. This strategy can be further divided into "eager" or "lazy" pull. The lazy version of push-based gossip differs because a node, instead of directly sending the full payload, sends an identifier (such as a hash). The partner will then respond if he wants or not the full payload. \\
Instead, in pull-based strategies, a node randomly selects a peer in the network and ask for recently or available information. Upon receiving that list, they exchange missing information by directly asking the partner for them. \\
Selecting the best strategy is a matter of trade-off: push-based strategies archive a better convergence rate (as they require one less message exchange w.r.t the other strategies) but also produce more redundant data, meaning a higher waste of bandwidth and resources.
There is also the possibility to combine the strategies mentioned above to create more efficient but more complex protocols. \\
One example of such strategy is the eager push and pull, which is characterized by the fact that gossiping is divided into 2 phases: a first one where peers exchange information through a push-based strategy and a second where a pull-based method is used in order to minimize redundant data. \\
Gossip protocols are also characterized by how they manage the membership of the network, as each peer can maintain a full-view or a partial-view of the network and structure of the network, as peers can be organized in tree or circle based shape. % TODO: EXPAND

\subsection{Gossip threats}
Peer in a blockchain network does not usually need to be registrered as no PKI infrastructure exists. This fact is perfect to increase the level of decentralization, but it also introduces no way of punishing a misbehaving peer, as he can easily change his identity.
The most dangerous attacks on this kind of p2p networks are rational attacks, Sybil attack, and Eclipse attacks. \\
The first one includes all those scenarios where a peer acts selfishly the increasing the load of other more altruistic peers. An example is a peer who always asks for updates without sharing anything, minimizing the use of his resources and maximizing his gain. \\
A Sybil attack is a kind of security threat where one person tries to take over the network by creating multiple identities. In a blockchain-context, a malicious actor could create a high number of nodes polluting most of the network's view of other peers. This scenario could lead to a bad situation where most fo peer would not be able to receive or transmit information. \\
Eclipse attacks are a more powerful Sybil attack where an attacker is able to pollute the whole network view of a peer, meaning that the victim cannot understand whether the information he receives is correct or not.
\subsection{Gossip in blockchains}
As of 2019, many blockchains were born, each one providing different services, ranging from financial to juridical and gossip protocol. Most of the time, the p2p network is used to propagate messaging containing blocks or transactions, but there are also examples of blockchain which use gossip to disseminate message for consensus purposes.\\
The most famous and most used blockchain is Bitcoin. In the Bitcoin p2p network, peers maintain a routing table containing the connection information of all the peers they have known about until that time. Every $\Delta$ time $T$, a subset of peers is chosen to start exchange messages using a lazy push-based strategy. Another relevant blockchain is Ethereum, which gossip protocol is pretty similar to Bitcoin's. One relevant fact about Ethereum's p2p protocol is the fact that it has been found vulnerable to an eclipse attack in 2015 and since then a new peer sampling mechanism has been added to remove the issue. \\
Looking at less decentralized blockchain, we have Hyperledger Fabric which divides gossip into push-based and pull-based times. Another one of this kind is Tendermint, which instead follows an eager push-based strategy. Tendermint exploits also gossip to disseminate consensus messages between validators.

\section{BAR model \& BAR Gossip}
Traditionally, fault-tolerance theory admits three different models to describe actor's behaviors, determining how much the system can withstand part of it deviating from the protocol. \\
The first model is the simple fault-tolerance, where the idea is that each actor can either precisely follow the protocol or fail, meaning that the system has to be able to detect and recover from failures. This model is most useful in those scenarios where the system is architecturally decentralized but politically centralized (ex. Google cloud hosting). \\
However, what if the considered system is managed by several organizations or individuals? In this case, the model has to in exchange for the Byzantine fault-tolerance, which states that most of the nodes will follow the protocol, but some of them will deviate either by acting maliciously or because they crash/fail. Byzantine fault-tolerance systems need to survive against a percentage of such deviating members. \\
The last, more realistic and complex model extends the notion of Byzantine fault-tolerance, is called Byzantine Altruistic Rational model an differs from the previous one by adding a simple reasoning: considering a real-life scenario, every actor's behavior in a system is determined by the incentives he gets when following the protocol. Most members of the system will always try to maximize their utility function even if this requires to deviate from the protocol. A simple example are push and pull forms of gossip: as peers are obligated to exchange information in a Tic-For-Tac fashion, they can ask for updates and never sharing them, increasing the load burden on a smaller subset of peers. \\
This is way BAR model assumes three types of actors:
\begin{itemize}
	\item Altruistic: actors who always follow the protocol.
	\item Rationals: actors who follow the protocol if it suits them, and do not follow the protocol if it does not.
	\item Byzantine: actors who only want to disrupt the system.
\end{itemize}
If a system survives under the assumptions of the BAR model, it is said to be incentive-compatible. \\
Looking at the literature, several gossip protocol, assuming the BAR model, have already been studied. One of the most famous is the work done in \{ cite here BAR Gossip\}, which developed the first data streaming application with predictable throughput and low latency. \\
 In BAR Gossip a central tracker distributes updates to a subset of peers, who will then disseminate them with other members of the network in such a way that every peer's action is accountable and provable. As to our knowledge, there is no work on gossip protocols assuming a BAR model in a blockchain-context.
\section{BAR Gossip in details}
Is it worth to explain how BAR Gossip works? Maybe it can lead to easier explanation later.
\section{Problem definition}
Is it worth adding this section to explain which are the problem and challenges of implementing BAR Gossip in a blockchain context?


\chapter{BBAR Gossip}
After having discussed the needed background, we can now move onto describing our BBAR Gossip protocol.\\
 It is important to remember that the primary goal of the protocol is to implement a more reliable p2p network able to withstand or minimize the attack surfaces introduced by p2p protocols. This goal must be persuaded, taking into account that decentralization and convergence rate is a crucial factor in a blockchain network, meaning it could severely impact overall performances.\\
This chapter will start describing the model assumption. It will then move to describe the several kinds of peers included in the network and their relationship. The last three sections will outline the actual protocol with a focus on implementation details and further optimizations.
\section{Model assumptions}
We are making the following assumption about our model:
\begin{itemize}
	\item The p2p network is not built upon any structure.
	\item Every peer in the network adheres to the BAR model.
	\item There exist two kinds of peers: validator and full node.
	\item Validators are block producers and can get punished for misbehaving.
	\item Validators do not know each other. If they need to talk, they do it by gossiping.
	\item Validators are also full nodes and are not recognizable by other peers.
	\item Identities of Validators are known and bound to a Public Key, but their network address is hidden and unknown.
	\item Full nodes keep track of network operations and can generate Proof-of-Misbehavior against malicious peers.
	\item There exist seed-nodes, which a newly joined peer can contact to receive an initial set of peer addresses.
\end{itemize}
Our model assumptions are compatible with most blockchain using PoS as consensus mechanism such as Tendermint.
\section{Cryptographic primitives}
In order to be able to make peers accountable for their actions, we need several kinds of cryptographic primitives: hash function, symmetric cryptography, asymmetric cryptography, and pseudo-random number generators. \\
Hash functions are any function which can be used to map arbitrary length data onto fixed size data. Moreover, we need hashing function with two more additional proprieties:
\begin{itemize}
	\item Pre-image resistance
	\item Second-image resistance
	\item Collision resistance
\end{itemize}
The hashing function chosen in our implementation is SHA256, but other good candidates are SHA3 or BLAKE2. \\
Symmetric encryption is an encryption mechanism that uses the same key to encrypt and decrypt some data. It is composed of an encryption algorithm, a decryption algorithm, the plain-text, the cipher-text, and a secret key. The encryption algorithm takes as parameters the plain-text and secret key and outputs the -cipher-text. The decryption algorithm takes as parameters the cipher-text and secret key and outputs the plain-text. The symmetric encryption algorithm chosen in our implementation is AES256, but Salsa20 or ChaCha are also good candidates. \\
Asymmetric encryption uses two key, one called private and one public, to either encrypt/decrypt or perform digital signatures. Digital signatures are a mathematical technique to validate the authenticity and integrity of a message and are usually used to acknowledge the consent of the signer.  \\
Our implementation uses Elliptic Curve cryptography.
Pseudo-random number generators are algorithms that deterministically generates a sequence of numbers whose properties approximate the properties of sequences of random numbers. PRNGs cannot be considered really random as their output is totally determined by an initial value called seed. Our implementation follows the Mersenne Twister PRNG, but the XORShift PNRG family is also a good candidate.
\section{Type of peers}
BBAR Gossip introduces two new different node types in the network along with the standard validator, full and seed node. It also modifies the default behaviour of seed node. \\
The new nodes are called bootstrap and entry nodes. Each node has a particular role in the network. \\
\begin{itemize}
	\item Bootstrap nodes are the main difference with traditional gossips. Its primary purpose is to register and keep track of new peers, remove malicious peer, and coordinate the exchange of messages. Each Bootstrap node identity is tied to a corresponding validator's identity as they can be made accountable for their actions and, in case of misbehaviour, be slashed.
	\item Entry nodes are an additional component of every bootstrap node. They act as reverse proxies to keep the network identity (IP address) of the bootstrap node hidden to avoid DDoS attacks.
	\item Full nodes are simple peers in the network who want to exchange messages with other peers to sync their state. They have different behaviour as they agree to the BAR model.
	\item Seeds node keep track of bootstrap node's addresses as new peers need to be able to contact a bootstrap node to start interacting with the network.
\end{itemize}

\section{Protocol description}
We have divided the protocol into three phases, which a peer has to follow to start exchanging messages and sync his state. 
\subsection{Epoch concept}
A cardinal concept and crucial building block of the protocol is the notion of Epoch.  \\
An epoch is a $\Delta$ $T$ time used to divide time and synchronize peers, and each Bootstrap node decides how long an epoch last. Epochs have to be a monotonically increasing sequence of numbers and must not overlap.
\subsection{Registraton phase}
We have divided the protocol into three phases, which a peer has to follow to start exchanging messages and sync his state. 

\begin{figure}[h]
  \includegraphics[width=\linewidth]{images/register-phase.png}
  \caption{Register phase chart}
  \label{fig:register-phase}
\end{figure}

The first thing a peer has to do to be included in a network is to contact a seed node to receive some bootstrap's entry points addresses. From the list of addresses, the peer will randomly contact a subset of them and start the following message exchange.
\begin{itemize}
	\item Peer sends a HELLO message[\ref{tab:hello-message}] to the entry node/s, with his public-key and network address.
	\item Entry node/s contact the Bootstrap node and send back a REGISTRATION message[\ref{tab:register-message}] , which includes a Hashcash-style puzzle and the corresponding difficulty.
	\item As soon as the peer finds a solution for the crypto-puzzle, it sends to the entry node/s a LOGIN message[\ref{tab:login-message}] , including the solution.
	\item The entry node/s checks the validity of the solution. If the solution is valid, sends back a TOKEN message and includes the peer information in the next epoch. Together with a TOKEN message, a VIEW[\ref{tab:view-message}] message is also sent.
\end{itemize}
  
Each bootstrap node can choose the difficulty of the desired solution, meaning that they can control how many registrations they get on average in the next $T$ epochs.\\
In the last step, after checking that the solution is valid, the entry nodes returns a TOKEN message. The TOKEN message contains a digital signature over the hash of the string generated as the concatenation of the crypto-puzzle, the corresponding solution, and epoch. It is possible for everyone, using this format, to check the validity of the Hashcash solution, (to avoid collusion between the bootstrap node and a peer) and bind the token to a specific epoch. Moreover, the TOKEN message, includes a field called Key, which stores 16 random bytes which will be used later in the protocol. \\
Still in the last step, the entry nodes sends also a VIEW message which contains a list of all the registered peers with their informations and the next epoch 
time. \\
When the next epoch start, every peer in the network has to send back their token to the corresponding Bootstrap node. If the Bootstrap node does not have any PoM against that peer, it will send back a new TOKEN and VIEW message.
\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
           & \textbf{Size}            & \textbf{Description}                                            \\ \hline
\textbf{Host}       & variable length & Network address of the peer                            \\ \hline
\textbf{Port}       & 4 byte          & Network port of the peer                               \\ \hline
\textbf{Public Key} & 33 byte         & Public key encoded as the x coordinate and oddness bit \\ \hline
\end{tabular}
}
\caption{Login message description}
\label{tab:hello-message}
\end{table}

\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{|l|l|l|}
\hline
           & \textbf{Size}     & \textbf{Description}                                                  \\ \hline
\textbf{Difficulty} & 4 bytes  & Integer describing the difficulty of the solution            \\ \hline
\textbf{Puzzle}     & 49 bytes & Concatenation of the encoded public-key plus a 16 byte nonce \\ \hline
\end{tabular}
}
\caption{Register message description}
\label{tab:register-message}
\end{table}

\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{|l|l|l|}
\hline
       & \textbf{Size}            & \textbf{Description}                                                  \\ \hline
\textbf{Puzzle} & 49 bytes        & Concatenation of the encoded public-key plus a 16 byte nonce \\ \hline
\textbf{Proof}  & Variable length & The solution to the crypto-puzzle                            \\ \hline
\end{tabular}
}
\caption{Login message description}
\label{tab:login-message}
\end{table}


\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{|l|l|l|}
\hline
                & \textbf{Size}         & \textbf{Description}                                         \\ \hline
\textbf{Puzzle} & 49 bytes              & Concatenation of the encoded public-key plus a 16 byte nonce \\ \hline
\textbf{Proof}  & Variable length       & The solution to the crypto-puzzle                            \\ \hline
\textbf{Token}  & 71 bytes (on average) & The BN digital signature used as token                       \\ \hline
\textbf{Epoch}  & 4 bytes               & The integer describing the current epoch                     \\ \hline
\textbf{Key}    & 16 bytes              & Random data used as encryption key                           \\ \hline
\end{tabular}
}
\caption{Token message description}
\label{tab:token-message}
\end{table}

\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{|l|l|l|}
\hline
                    & \textbf{Size}   & \textbf{Description}                                        \\ \hline
\textbf{Peer List}  & Variable length & List of peer and their corresponding PK and network address \\ \hline
\textbf{Epoch}      & 4 byte          & Integer describing the epoch                                \\ \hline
\textbf{Next epoch} & 4 byte          & Unix timestamp of the next epoch time                       \\ \hline
\end{tabular}
}
\caption{View message description}
\label{tab:view-message}
\end{table}



\subsection{Peer selection phase}
\subsection{Message exchange phase}
\section{Details}
\section{Optimizations}

\chapter{Evaluation}
\section{BBAR vs BAR}
\section{Simulation vs Prototype}

\chapter{Experiments}
\section{Setup}
\section{Convergences rate}
\section{Duplicates}
\section{Edge cases}

\chapter{Conclusions}
\section{Discussion}
\section{Future works}


%\chapter[Short title]{A chapter title which will run over two lines --- it's for
%  testing purpose}
%
%\lipsum[1-2]
%
%\section{The first section}
%\lipsum[3-4]
%
%\appendix %optional, use only if you have an appendix
%
%\chapter{Some retarded material}
%\section{It's over\dots}
%\lipsum 
%
%\backmatter
%
%\chapter{Glossary} %optional

%\bibliographystyle{alpha}
%\bibliographystyle{dcu}
\bibliographystyle{plainnat}
\bibliography{biblio}

%\cleardoublepage
%\theindex %optional, use only if you have an index, must use
	  %\makeindex in the preamble
\lipsum

\end{document}
